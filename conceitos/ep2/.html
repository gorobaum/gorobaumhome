<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0045)http://www.ime.usp.br/~reverbel/CLP-11/eps/2/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>MAC0316/5754 - Segundo Exercício-Programa</title>
<link rel="stylesheet" href="./ep2_files/stylesheet.css" type="text/css">

</head>

<body>
<h2>Segundo Exercício-Programa: Interpretador Estendido</h2>
<h3 class="Subheading">
MAC0316/MAC5754 - Conceitos de Linguagens de Programação
</h3>
<p>

O segundo exercício-programa é o <a href="http://www.cs.brown.edu/courses/cs173/2008/Assignments/02-xinterp.html"><em>Extended
Interpreter</em></a> proposto por <a href="http://www.cs.brown.edu/~sk/">Sriram Krishnamurthy</a> (o autor do
PLAI), com as modificações especificadas abaixo.</p><p>

</p><h3>Modificações em relação à proposta original</h3>
<p>
Faremos três modificações no <a href="http://www.cs.brown.edu/courses/cs173/2008/Assignments/02-xinterp.html">enunciado
original</a> do Prof. Krishnamurthy. As duas primeiras são burocráticas e a
terceira é de conteúdo.
</p><p>
Estas são as modificações burocráticas: 
</p><ul>
  <li>Substitua as ocorrências de "DrScheme" por "DrRacket".</li>
  <li>Em vez de entregar dois arquivos (<code>xinterp.ss</code> e
      <code>xinterp-lazy.ss</code>), siga a convenção de entrega definida
      ao final desta página.</li> 
</ul>

Vejamos agora a modificação não burocrática. Na <a href="http://www.cs.brown.edu/courses/cs173/2008/Assignments/02-xinterp.html">proposta
original</a> de S. Krishnamurthy, a forma <code>with</code> aparece tanto
na sintaxe concreta como na sintaxe abstrata da linguagem CFWAE. Como a
definição do tipo <code>CFWAE</code> inclui uma variante <code>with</code>,
essa proposta permite (mas não obriga) que um <em>parser</em> gere árvores
sintáticas contendo nós <code>with</code>.  Em outras palavras, o enunciado
original permite que você decida se o seu <em>parser</em> vai ou não vai gerar
árvores sintáticas contendo nós <code>with</code>. Essa decisão separa as
possíveis soluções em duas categorias:
<ol>
  <li>Num tipo de solução, o <em>parser</em> traduz ocorrências concretas da
      forma sintática <code>with</code> em nós <code>with</code> da árvore
      sintática.<p></p></li> 
  <li>No outro tipo de solução, o <em>parser</em> converte ocorrências
      concretas da forma sintática <code>with</code> em chamadas a funções
      anônimas, da maneira descrita no PLAI e vista em classe. Cada ocorrência
      da forma <code>with</code> no programa concreto gera um nó
      <code>app</code> da árvore sintática. Neste tipo de solução, as árvores
      sintáticas nunca conterão nós <code>with</code>. Embora permitidos pela
      sintaxe abstrata, tais nós não serão utilizados.<p></p></li> 
</ol>
Na alternativa 2, o <code>with</code> é apenas um modo conveniente ("acúcar
sintático") para representar uma chamada a uma função anônima. Essa
alternativa simplifica a implementação do interpretador, pois somente o
<em>parser</em> precisa lidar com a forma <code>with</code>. Além disso,
considero que a alternativa 2 é a "mais educativa", pois ela mostra, de modo
bem concreto, que formas como a <code>with</code> (ou como a forma
<code>let</code> do Scheme) não são construções essenciais.
<p>
Em vez de deixar a seu critério a escolha entre os dois tipos de soluções
acima, resolvi especificar que <u>deve ser implementada uma solução do tipo
2</u>. É essa a diferença básica entre este exercício-programa e o proposto
por S. Krishnamurthy. Tudo o que segue é consequência dessa decisão. 
</p><p>
Já que nossas árvores sintáticas nunca conterão nós <code>with</code>, podemos
eliminar da sintaxe abstrata o tipo correspondente a esses nós, ou seja,
podemos remover a variante <code>with</code> do <code>define-type</code> para
<code>CFWAE</code>. Podemos remover também a definição do tipo
<code>Binding</code>, pois esse tipo aparece somente na variante
<code>with</code>. Essas alterações devem ser aplicadas ao código que está
na seção <em>Support Code</em> do enunciado original. Em vez do modelo
especificado na seção <em>Support Code</em>, use o seguinte modelo de código
(sem fazer nenhuma alteração nele): 
</p><p>
</p><pre>(define-type CFAE
  [num (n number?)]
  [binop (op procedure?) (lhs CFAE?) (rhs CFAE?)]
  [id (name symbol?)]
  [if0 (c CFAE?) (t CFAE?) (e CFAE?)]
  [fun (args (listof symbol?)) (body CFAE?)]
  [app (f CFAE?) (args (listof CFAE?))])

(define-type Env
  [mtEnv]
  [anEnv (name symbol?) (value CFAE-Value?) (env Env?)])

(define-type CFAE-Value
  [numV (n number?)]
  [closureV (params (listof symbol?))
            (body CFAE?)
            (env Env?)])

;; parse : expression -&gt; CFAE
;; This procedure parses an expression into a CFAE
(define (parse sexp)
  ...)

;; interp : CFAE -&gt; CFAE-Value
;; This procedure interprets the given CFAE and produces a result
;; in the form of a CFAE-Value (either a closureV or a numV)
(define (interp expr)
  ...)

</pre>
<p>
Note que o tipo <code>CFWAE</code> do modelo original foi renomeado para
<code>CFAE</code>, já que o <code>with</code> desapareceu da sintaxe
abstrata (embora continue presente na sintaxe concreta CFWAE). Agora a função 
<code>parse</code> recebe uma <em>s-expression</em> com uma expressão CFWAE e
devolve a instância do tipo <code>CFAE</code> que é a raiz da árvore sintática 
correspondente. 
</p><p>
Na segunda parte do exercício-programa (avaliação preguiçosa), o tipo
<code>CFAE-Value</code> deve conter uma variante <code>exprV</code>:
</p><pre>(define-type CFAE-Value
  [numV (n number?)]
  [closureV (params (listof symbol?))
            (body CFAE?)
            (env Env?)]
  [exprV (expr CFAE?) (env Env?)]))
</pre>
<p>
Caso você decida implementar avaliação preguiçosa com <em>caching</em> (a
implementação de <em>caching</em> é <u>opcional</u> - quem a fizer receberá
um bônus na nota deste EP), sua variante <code>exprV</code> terá um terceiro
campo. Esse campo deverá ser uma <code>box</code> mutável, análoga à usada
na seção 8.2 do PLAI (vide código na página 78 e listagens nas figuras 8.3 e
8.4).
</p><p>
</p><h3>Sobre a entrega</h3>
Este EP deve ser feito individualmente. Entregue sua solução até o dia
3 de maio, pelo sistema <a href="http://paca.ime.usp.br/">Paca/Moodle</a>.
<p>
Deve ser entregue um arquivo tar.gz ou zip que satisfaça os seguintes
requisitos:</p><p>
</p><ul>
  <li>O nome do arquivo deve ser da forma
      <code>ep2-&lt;seu-nome&gt;.tar.gz</code> ou
      <code>ep2-&lt;seu-nome&gt;.zip</code>.
      Por exemplo: <code>ep2-fulano-de-tal.zip</code>.
      No nome do arquivo devem ser omitidos os
      acentos do seu nome. Além disso, a separação entre palavras não deve ser feita
      com espaços. Ou seja, o arquivo não deve se chamar 
      "<code>ep2-joão-da-silva.zip</code>" nem
      "<code>ep2&nbsp;joao&nbsp;da&nbsp;silva.zip</code>".<p></p></li>
      
  <li>O desempacotamento do arquivo tar.gz ou zip deve produzir um
      diretório com o mesmo nome do arquivo, menos o sufixo
      <code>.tar.gz</code> ou <code>.zip</code>. (Exemplo:
      <code>ep2-fulano-de-tal</code>.) Todos os arquivos desempacotados devem
      estar dentro desse diretório.<p></p></li>
      
  <li>O diretório desempacotado deve conter:<p>
      </p><ul>
	<li>o seu arquivo <code>xinterp.ss</code>, com a primeira parte do
	    exercício-programa (avaliação ávida);<p></p></li> 
	<li>o seu arquivo <code>xinterp-lazy.ss</code>, com a segunda parte do
	    exercício-programa (avaliação preguiçosa).<p></p></li>
      </ul><p></p></li>
</ul>

<p>
</p><hr>
<address>

<a href="http://jigsaw.w3.org/css-validator"><img src="./ep2_files/vcss.gif" alt="Valid CSS!" align="right" border="0" width="88" height="31"></a>  
<a href="http://validator.w3.org/check/referer"><img src="./ep2_files/vxhtml10.gif" alt="Valid XHTML 1.0!" align="right" border="0" width="88" height="31"></a>  
<!-- hhmts start -->
Last modified: Thu Apr 14 23:02:57 BRT 2011
<!-- hhmts end -->
<br>
</address>



</body></html>